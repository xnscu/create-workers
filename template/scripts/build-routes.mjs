import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const apiDir = path.join(__dirname, '../worker')
const outputFile = path.join(__dirname, '../worker/index.mjs')

// Dynamically check if file exports ClassView subclass
async function isClassViewFile(filePath) {
  try {
    // Use file:// URL for import
    const fileUrl = 'file://' + filePath

    // Dynamic import module
    const module = await import(fileUrl)
    const exportedClass = module.default || module

    // Check if it's a class and inherits from ClassView
    if (typeof exportedClass === 'function' && exportedClass.prototype) {
      // Import ClassView for comparison
      const { ClassView } = await import('../lib/classview.mjs')

      // Check prototype chain
      let proto = exportedClass.prototype
      while (proto) {
        if (proto.constructor === ClassView) {
          return true
        }
        proto = Object.getPrototypeOf(proto)
        // Avoid infinite loop
        if (proto === Object.prototype) {
          break
        }
      }
    }

    return false
  } catch (err) {
    // If dynamic import fails, fallback to static analysis
    console.warn(
      `Unable to dynamically check file ${filePath}, falling back to static analysis: ${err.message}`,
    )
    try {
      const content = fs.readFileSync(filePath, 'utf8')
      return (
        content.includes('extends ClassView') ||
        content.includes('ClassView') ||
        (content.includes('from ') && content.includes('classview'))
      )
    } catch (staticErr) {
      console.warn(`Static analysis also failed: ${staticErr.message}`)
      return false
    }
  }
}

async function scanApiFiles(dir, basePath = '') {
  const routes = []

  if (!fs.existsSync(dir)) {
    console.log('API directory does not exist, creating empty route index')
    return routes
  }

  const files = fs.readdirSync(dir)

  for (const file of files) {
    const fullPath = path.join(dir, file)
    const stat = fs.statSync(fullPath)

    if (stat.isDirectory()) {
      // Recursively scan subdirectories
      routes.push(...(await scanApiFiles(fullPath, path.join(basePath, file))))
    } else if ((file.endsWith('.mjs') || file.endsWith('.js')) && file.split('.')[0] !== 'index') {
      // Generate route path
      const routePath = path.join(basePath, file.replace(/\.(mjs|js)$/, ''))
      const normalizedPath = '/' + routePath.replace(/\\/g, '/')
      const importPath = './' + path.join(basePath, file).replace(/\\/g, '/')

      // Dynamically check if it's a ClassView file
      const isClassView = await isClassViewFile(fullPath)

      routes.push({
        path: normalizedPath === '/index' ? '/' : normalizedPath,
        importPath,
        filename: file,
        isClassView,
      })
    }
  }

  return routes
}

// Scan API files (now async function)
const routes = await scanApiFiles(apiDir)

// Generate route index file
const indexContent = `// Auto-generated route index file
// Generated by scripts/build-routes.mjs

import Router from "../lib/router.mjs";
import { ClassView } from "../lib/classview.mjs";

${routes
  .map((route, index) => {
    if (route.isClassView) {
      return `import Route${index}Module from '${route.importPath}';`
    } else {
      return `import route${index} from '${route.importPath}';`
    }
  })
  .join('\n')}

function wrapClassView(ViewClass) {
  if (ViewClass.prototype instanceof ClassView || ViewClass === ClassView) {
    return async (request, env, ctx) => {
      const instance = new ViewClass();
      return await instance.dispatch(request, env, ctx);
    };
  }
  return ViewClass;
}

export const routes = [
${routes
  .map((route, index) => {
    if (route.isClassView) {
      return `  ['${route.path}', wrapClassView(Route${index}Module.default || Route${index}Module)]`
    } else {
      return `  ['${route.path}', route${index}]`
    }
  })
  .join(',\n')}
];
const router = Router.create(routes);

function dispatchResponse(resp, status = 200) {
  const respType = typeof resp;

  if (
    (respType === "object" && resp !== null) ||
    respType === "boolean" ||
    respType === "number"
  ) {
    let json;
    try {
      json = JSON.stringify(resp);
    } catch (err) {
      return Router.internalServerErrorResponse(
        "Error when encoding response: " + err.message,
      );
    }

    return new Response(json, {
      status: status,
      headers: {
        "Content-Type": "application/json; charset=utf-8",
        "Cache-Control": "no-store",
      },
    });
  } else if (respType === "string") {
    const contentType = resp.startsWith("<")
      ? "text/html; charset=utf-8"
      : "text/plain; charset=utf-8";

    return new Response(resp, {
      status: status,
      headers: {
        "Content-Type": contentType,
        "Cache-Control": "no-store",
      },
    });
  } else {
    return Router.internalServerErrorResponse(
      \`Invalid response type: \${respType}\`,
    );
  }
}

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;
    if (path.startsWith("/api/")) {
      try {
        const method = request.method;

        const { handler, params } = router.match(path.slice(4), method);
        request.params = params;
        const result = await handler(request, env, ctx);

        if (result instanceof Response) {
          return result;
        }

        return dispatchResponse(result, 200);
      } catch (error) {
        if (error instanceof Router.NotFoundError) {
          return Router.notFoundResponse(error.message);
        } else if (error instanceof Router.MethodNotAllowedError) {
          return Router.methodNotAllowedResponse(request);
        } else {
          return Router.internalServerErrorResponse(error.message);
        }
      }
    } else {
      return new Response(null, { status: 404 });
    }
  },
};
`

// Ensure output directory exists
fs.mkdirSync(path.dirname(outputFile), { recursive: true })

// Write file
fs.writeFileSync(outputFile, indexContent)

console.log(`Route index file generated: ${outputFile}`)
console.log(`Found ${routes.length} API files:`)
routes.forEach((route) => {
  const typeLabel = route.isClassView ? '[ClassView]' : '[Function]'
  console.log(`  ${typeLabel} ${route.path} -> ${route.importPath}`)
})
