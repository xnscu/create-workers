import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const apiDir = path.join(__dirname, '../worker')
const outputFile = path.join(__dirname, '../worker/index.mjs')

// Dynamically check if file exports ClassView subclass
async function isClassViewFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8')
    return (
      content.includes('extends ClassView') ||
      content.includes('ClassView') ||
      (content.includes('from ') && content.includes('ClassView'))
    )
  } catch (staticErr) {
    console.warn(`Static analysis also failed: ${staticErr.message}`)
    return false
  }
}

async function scanApiFiles(dir, basePath = '') {
  const routes = []

  if (!fs.existsSync(dir)) {
    console.log('API directory does not exist, creating empty route index')
    return routes
  }

  const files = fs.readdirSync(dir)

  for (const file of files) {
    const fullPath = path.join(dir, file)
    const stat = fs.statSync(fullPath)

    if (stat.isDirectory()) {
      // Recursively scan subdirectories
      routes.push(...(await scanApiFiles(fullPath, path.join(basePath, file))))
    } else if ((file.endsWith('.mjs') || file.endsWith('.js')) && file.split('.')[0] !== 'index') {
      // Generate route path
      let routePath = path.join(basePath, file.replace(/\.(mjs|js)$/, ''))

      // Convert [param] format to :param format
      routePath = routePath.replace(/\[([^\]]+)\]/g, ':$1')

      const normalizedPath = '/' + routePath.replace(/\\/g, '/')
      const importPath = './' + path.join(basePath, file).replace(/\\/g, '/')

      // Dynamically check if it's a ClassView file
      const isClassView = await isClassViewFile(fullPath)

      routes.push({
        path: normalizedPath === '/index' ? '/' : normalizedPath,
        importPath,
        filename: file,
        isClassView,
      })
    }
  }

  return routes
}

// Scan API files (now async function)
const routes = await scanApiFiles(apiDir)

// Generate route index file
const indexContent = `// Auto-generated route index file
// Generated by scripts/build-routes.mjs

import Router from '../lib/Router.mjs'
import ClassView from '../lib/ClassView.mjs'

${routes
  .map((route, index) => {
    if (route.isClassView) {
      return `import Route${index}Module from '${route.importPath}'`
    } else {
      return `import route${index} from '${route.importPath}'`
    }
  })
  .join('\n')}

function wrapClassView(ViewClass) {
  if (ViewClass.prototype instanceof ClassView || ViewClass === ClassView) {
    return async (request, env, ctx) => {
      const instance = new ViewClass()
      return await instance.dispatch(request, env, ctx)
    }
  }
  return ViewClass
}

const routes = [
${routes
  .map((route, index) => {
    if (route.isClassView) {
      return `  ['${route.path}', wrapClassView(Route${index}Module.default || Route${index}Module)]`
    } else {
      return `  ['${route.path}', route${index}]`
    }
  })
  .join(',\n')}
]
const router = Router.create(routes)

function dispatchResponse(resp, status = 200) {
  const respType = typeof resp

  if ((respType === 'object' && resp !== null) || respType === 'boolean' || respType === 'number') {
    let json
    try {
      json = JSON.stringify(resp)
    } catch (err) {
      return Router.internalServerErrorResponse('Error when encoding response: ' + err.message)
    }

    return new Response(json, {
      status: status,
      headers: {
        'Content-Type': 'application/json; charset=utf-8',
        'Cache-Control': 'no-store',
      },
    })
  } else if (respType === 'string') {
    const contentType = resp.startsWith('<')
      ? 'text/html; charset=utf-8'
      : 'text/plain; charset=utf-8'

    return new Response(resp, {
      status: status,
      headers: {
        'Content-Type': contentType,
        'Cache-Control': 'no-store',
      },
    })
  } else {
    return Router.internalServerErrorResponse(\`Invalid response type: \${respType}\`)
  }
}

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url)
    const path = url.pathname
    if (path.startsWith('/api/')) {
      try {
        const method = request.method

        const { handler, params } = router.match(path.slice(4), method)
        request.params = params
        const result = await handler(request, env, ctx)

        if (result instanceof Response) {
          return result
        }

        return dispatchResponse(result, 200)
      } catch (error) {
        if (error instanceof Router.NotFoundError) {
          return Router.notFoundResponse(error.message)
        } else if (error instanceof Router.MethodNotAllowedError) {
          return Router.methodNotAllowedResponse(request)
        } else {
          return Router.internalServerErrorResponse(error.message)
        }
      }
    } else {
      return new Response(null, { status: 404 })
    }
  },
}
`

// Ensure output directory exists
fs.mkdirSync(path.dirname(outputFile), { recursive: true })

// Write file
fs.writeFileSync(outputFile, indexContent)

console.log(`Route index file generated: ${outputFile}`)
console.log(`Found ${routes.length} API files:`)
routes.forEach((route) => {
  const typeLabel = route.isClassView ? '[ClassView]' : '[Function]'
  console.log(`  ${typeLabel} ${route.path} -> ${route.importPath}`)
})
